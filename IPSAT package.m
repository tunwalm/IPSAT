(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)


GrainBoundary[imagefile_,x_,y_]:=ColorNegate[Binarize[GaussianFilter[EdgeDetect[FillingTransform[DeleteSmallComponents[ColorNegate[MorphologicalBinarize[imagefile,{x,y}]],100]]],4,Padding->White]]];
(*This function is for loose sediment image. It thresholds with the x and y limits and binarizes the image for grain boundary*)


GrabImage[imagefile_]:=Module[{im,res,tmp,proc,data},
(* input a valid image file from the directory *)
im = ColorNegate[Binarize[imagefile]];
(*import, binarize and colornegate the image file*)
res = WatershedComponents[im];
(* distinguish the boundary of grains *)
ReplacementFunction[res_]:=Module[{res1,res2,res3},
res1 = res/.{res[[1,1]]->-1};
res2 = res1/.{1-> res[[1,1]]};
res3 = res2/.{-1-> 1}
];
res = If[res[[1,1]]==1,res,ReplacementFunction[res]];
tmp=Erosion[res,1,Padding->res[[1,1]]];
proc = (res - tmp);
proc = Pruning[Thinning[proc/.{res[[1,1]]->0}]];
(*proccessed matrix for extracting the boundary *)
data= Drop[ComponentMeasurements[res,{"Label","Centroid","Length","Width","Orientation","Rectangularity","Area","ConvexArea","ConvexPerimeterLength","PerimeterLength","CaliperLength"}],1];
(* measurements of grains *)
Print[Show[res//Colorize,Table[Graphics[{Red,Text[Style[data[[i,2,1]]-1,Medium],data[[i,2,2]],Background->White]}],{i,1,Length[data]}],ImageSize->Scaled[1]]];
{res,proc,data}
]


RefineImage[grabimagedata_,exclusion_]:= Module[{res,proc,data,label},
res = grabimagedata[[1]];
proc = grabimagedata[[2]];
data = grabimagedata[[3]];
(*data transfer from previous step*)
label = Complement[data[[All,1]],exclusion+1]-1;
(* exclusion of unwanted grains*)
Print[Show[res//Colorize,Table[Graphics[{Red,Text[Style[data[[label[[i]],2,1]]-1,Medium],data[[label[[i]],2,2]],Background->White]}],{i,1,Length[label]}],ImageSize->Scaled[1]]];
{label,res,proc,data,exclusion}]


ExtractData[refinedata_]:= Module[{res,proc,data,label,h,bpoints,inpoints,boundarypoints,orderedpoints,coordlist,insidepoints,cmdata,dist,minDist,centMass,Incircleradius,Inradiuslist,dim},
label = refinedata[[1]];
res = refinedata[[2]];
proc = refinedata[[3]];
data = refinedata[[4]];
(*data transfer from previous step*)
h = Dimensions[res][[1]];
(* height of image for coordinate transformation*)
bpoints = Table[Position[proc,label[[i]]+1],{i,1,Length[label]}];
(* boundary points taken as list*)
boundarypoints = Table[{bpoints[[i,j,2]],h+1-bpoints[[i,j,1]]},{i,1,Length[bpoints]},{j,1,Length[bpoints[[i]]]}];
(*coordinate transformation of boundary points*)
orderedpoints = Table[FindShortestTour[boundarypoints[[i]]], {i, 1,Length[boundarypoints]}];
(* taking order of boundary points *)
coordlist = Table[boundarypoints[[i,orderedpoints[[i, 2, j]]]],{i, 1,Length[orderedpoints]}, {j, 1, Length[orderedpoints[[i, 2]]]}];
(* coordinate list of boundary in orderely fashion*)
inpoints = Table[Position[res, label[[i]]+1], {i, 1, Length[label]}];
(* all coordinate points lying inside grains *)
insidepoints =  Table[{inpoints[[i,j,2]],h+1-inpoints[[i,j,1]]},{i,1,Length[inpoints]},{j,1,Length[inpoints[[i]]]}];
(* coordinate transformation of inside points *)
cmdata = Table[data[[label[[i]],2]],{i,1,Length[label]}];
(* measurement data already extracted from grains *)
dim = Dimensions[res];
{coordlist, insidepoints, cmdata,inpoints,dim}
]


CircumscribedCircle[exdata_]:= Module[{centerpoints,insidedata,constraintlist,cordlist,radiuslist,dialist},
dist[x_, y_] := Norm[{Norm[x[[1]] - y[[1]]], Norm[x[[2]] - y[[2]]]}];
(*function defined for distance between two points*)
maxDist[bound_, point_] := Max[Table[dist[bound[[i]], point], {i, 1, Length[bound]}]];
(*function defined for minimum distance between a point to any point on the boundary*)


centerpoints = exdata[[3]][[All,2]];
(* centroid of grains *)
insidedata = exdata[[2]];
(* list of inside points within grain *)
constraintlist = Table[{Max[insidedata[[i]][[All,1]]],Min[insidedata[[i]][[All,1]]],Max[insidedata[[i]][[All,2]]],Min[insidedata[[i]][[All,2]]]},{i,1,Length[insidedata]}];
(* list of x,y constraints *)
cordlist = exdata[[1]];
(* list of boundary coordinates *)
radiuslist = Table[Quiet[FindMinimum[maxDist[cordlist[[i]],{x,y}],{{x,centerpoints[[i,1]],constraintlist[[i,2]],constraintlist[[i,1]]},{y,centerpoints[[i,2]],constraintlist[[i,4]],constraintlist[[i,3]]}}]],{i,1,Length[cordlist]}];
(* calculates radius of smallest circumscribing circle over each grain *)
dialist = 2radiuslist[[All,1]];
(* size of is taken as diameter of smallest cicumscribing circle *)

dialist
(* gives output list of circumscribing circle diameter list*)
];


SizeData[exdata_,circumdata_,actualwidth_]:=Module[{d,factor,impdata,boundpoints,SizeC,SizeP,SizeD,SizeA,SizeB,SizeM,sizelist},
dist[x_, y_] := Norm[{Norm[x[[1]] - y[[1]]], Norm[x[[2]] - y[[2]]]}];
d = exdata[[5]];
(* width of image input in pixels *)
factor = actualwidth/d[[2]];
(* conversion factor *)
impdata=exdata[[3]];
boundpoints=exdata[[1]];
SizeC=factor*circumdata;
SizeP=factor*N[impdata[[All,10]]/Pi];
SizeD=factor*2*Sqrt[impdata[[#,7]]/Pi]&/@Range[Length[impdata]];
SizeA=factor*impdata[[All,3]];
SizeB=factor*impdata[[All,4]];
SizeM=factor*2*Mean[Table[dist[boundpoints[[#,i]],impdata[[#,2]]],{i,1,Length[boundpoints[[#]]]}]]&/@Range[Length[boundpoints]];
sizelist={{"SizeC",SizeC},{"SizeP",SizeP},{"SizeD",SizeD},{"SizeA",SizeA},{"SizeB",SizeB},{"SizeM",SizeM}}
];


InscribedCircle[extdata_] := Module[{coordList,insidePoints,data1,dist,minDist,initPoints,newIncuy,finalfun,Rect,Incircle},
coordList = extdata[[1]];
insidePoints = extdata[[2]];
data1 = extdata[[3]];
(* transfers required data for this step*)
dist[x_, y_] := Norm[{Norm[x[[1]] - y[[1]]], Norm[x[[2]] - y[[2]]]}];
(*function defined for distance between two points*)
minDist[bound_, point_] := Min[Table[dist[bound[[i]], point], {i, 1, Length[bound]}]];
(*function defined for minimum distance between a point to any point on the boundary*)

Rect[obpoint_] := Module[{r,t},
 r = Table[obpoint[[i,1]],{i,1,Length[obpoint]}];
t = Table[obpoint[[i,2]],{i,1,Length[obpoint]}];
{{Min[r],Min[t]},{Max[r],Max[t]}}];

Incircle[boundary_,inside_]:=Module[{r,div=20,a,b,c,d,z,clippedz,listminDist,inc,rad,inccord,r1,a1,b1,c1,d1,z1,listminDist1,inc1,rad1,inccord1}, 
r = Rect[boundary];
a = (r[[2,2]] - r[[1,2]])/div;
b = (r[[2,1]] - r[[1,1]])/div;
c = Table[{r[[1,1]]+i*b, r[[1,2]]+j*a},{i,0,div,1},{j,0,div,1}];
d = Table[{(c[[i,j,1]] + c[[i,j+1,1]]+c[[i+1,j,1]]+c[[i+1,j+1,1]])/4,(c[[i,j,2]] + c[[i,j+1,2]]+c[[i+1,j,2]]+c[[i+1,j+1,2]])/4},{i,1,div},{j,1,div}];
z =Flatten[d,1];
clippedz = Intersection[Round[z],inside];
listminDist = Table[ minDist[boundary,clippedz[[i]]],{i,1,Length[clippedz]}];
inc  = Position[listminDist,Max[listminDist]];
rad = Max[listminDist];
inccord = clippedz[[inc[[1,1]]]];
r1 = {{inccord[[1]]+b,inccord[[2]]+a},{inccord[[1]]-b,inccord[[2]]-a}};
a1 = (r1[[2,2]] - r1[[1,2]])/div;
b1 = (r1[[2,1]] - r1[[1,1]])/div;
c1 = Table[{r1[[1,1]]+i*b1, r1[[1,2]]+j*a1},{i,0,div,1},{j,0,div,1}];
d1 = Table[{(c1[[i,j,1]] + c1[[i,j+1,1]]+c1[[i+1,j,1]]+c1[[i+1,j+1,1]])/4,(c1[[i,j,2]] + c1[[i,j+1,2]]+c1[[i+1,j,2]]+c1[[i+1,j+1,2]])/4},{i,1,div},{j,1,div}];
z1 =Flatten[d1,1];
listminDist1 = Table[ minDist[boundary,z1[[i]]],{i,1,Length[z1]}];
inc1  = Position[listminDist1,Max[listminDist1]];
rad1 = Max[listminDist1];
inccord1 = z1[[inc1[[1,1]]]];
N@{inccord1,rad1}
];
initPoints[t_]:= Module[{r,xc,yc,c1,c2,m,n,th,w=8},
r = data1[[t,2]];
xc = r[[1]];
yc = r[[2]];
th = data1[[t,5]];
m = data1[[t,3]]/3;
n = data1[[t,4]]/3;
c1 = {xc+ m*Cos[th],yc+ m*Sin[th]};
c2 = {xc- m*Cos[th],yc- m*Sin[th]};
Table[{(i*c1[[1]]+(w-i)*c2[[1]])/w,(i*c1[[2]]+(w-i)*c2[[2]])/w},{i,0,w,1}]
];
(* function to generate list of points to give as starting point for maxima function*)

newIncuy[boundary_,t_,xcyc_]:=Module[{xcon,ycon,a,rad,inccord}, 
xcon={Min[insidePoints[[t]][[All,1]]],Max[insidePoints[[t]][[All,1]]]};
ycon={Min[insidePoints[[t]][[All,2]]],Max[insidePoints[[t]][[All,2]]]};
(* generates constraint for the maxima function *)
a = Quiet[FindMaximum[minDist[boundary,{x,y}],{{x,xcyc[[1]],xcon[[1]],xcon[[2]]},{y,xcyc[[2]],ycon[[1]],ycon[[2]]}}]];
(* function to maximise minimum distance from the boundary points *)
rad = a[[1]];
(* maximum distance calculated for a particular starting point*)
inccord = {a[[2,1,2]],a[[2,2,2]]};
(* point from which the maximum is calculated *)
{inccord,rad}
(* gives max distance and the point as output *)
];

finalfun[t_]:=Module[{inpoints,listmax,refinemax,res},
inpoints = initPoints[t];
listmax = Table[newIncuy[coordList[[t]],t,inpoints[[i]]],{i,1,Length[inpoints]}];
(* calculates max distance for list of starting points *)
refinemax =Select[listmax,MemberQ[insidePoints[[t]],Round[#[[1]]]]==True&];
(* selects max distances only for the points lying inside the boundary of grain *)
res = If[Length[refinemax]==0,Incircle[coordList[[t]],insidePoints[[t]]],Last[SortBy[refinemax,Last]]]

];

Table[finalfun[i],{i,1,Length[coordList]}]
(* generates list of largest inscribed circle along with its centre coordinates for each grain *)
];



FourierDescriptors[data_,num_]:=Module[{boundarylist,centerlist,normBound,normboundlist,descriptors},
boundarylist=data[[1]];
(*list of boundary points*)
centerlist=data[[3,All,2]];
(*list of grain centroid points*)
normBound[bound_,center_,number_]:=Module[{lenbound,centeredbp,scalebplist,scalebpIntpol,rescoord},
lenbound=Length[bound];
centeredbp=bound-ConstantArray[center,lenbound];
scalebplist=MapIndexed[{#2,#}&,centeredbp];
scalebpIntpol=Interpolation[scalebplist];
rescoord=Drop[scalebpIntpol/@Range[1,lenbound,(lenbound-1)/number],-1]
];
(*function for centering the grain at origin and representing it with num points given by user*)
normboundlist=normBound[boundarylist[[#]],centerlist[[#]],num]&/@Range[Length[boundarylist]];
(*list of normalised boundary points*)
descriptors = Table[Fourier[Transpose[normboundlist[[i]]][[1]] + I Transpose[normboundlist[[i]]][[2]]],{i,1,Length[normboundlist]}];
(* fourier descriptor calculation *)
descriptors
];


FractalDivider[data_]:= Module[{dist,bounDist,nlist,limlist,fractals,fractaldata},

nlist = Table[(data[[3,i,3]]+data[[3,i,4]])/29,{i,1,Length[data[[3]]]}];
limlist = nlist*2.5;
(*range of length dividors for each grains*)
dist[x_,y_]:=Norm[{Norm[x[[1]]-y[[1]]],Norm[x[[2]]-y[[2]]]}];
(*function defined for distance between two points*)
bounDist[obpoint_]:= N@Sum[dist[obpoint[[i]],obpoint[[i+1]]],{i,1,Length[obpoint]-1}];
(*function defined for calculating length of boundary*)


fractals[obpoints_,t_]:= Module[{F,H,fraclist,fracs, fpt,z,model,f,n,n1},
n1 = Table[i,{i,nlist[[t]],limlist[[t]],(limlist[[t]]-nlist[[t]])/8}];
n = Select[n1,#>Sqrt[2]&];
(*unit lengths for divider*)
F[val_,num_] := Module[{i,j},{i = j = 1;
While[dist[obpoints [[val]],obpoints [[i+val]]] < num && (val + i)< Length[obpoints] , j = i+val ;i++];
j+1}];
(* function defined to give next coordinate point with distance of divider length *)
H[in_,num_] := If[in < Length[obpoints]-num, F[in,num][[1]], Length[obpoints]];
(* function to identify last point *)
fraclist[num_] := Drop[FixedPointList[H[#,num]&,1],-1];
(* function to stop the calculation with last point *)
fpt = Table[obpoints[[fraclist[n[[i]]]]],{i,1,Length[n]}];
(* all coordinate points for dividers *)
fracs =  Table[bounDist[fpt[[i]]],{i,1,Length[fpt]}];
(* length of boundary for divider lengths *)
z = Table[{N[Log[10,n[[i]]]],Log[10,fracs[[i]]]},{i,1,Length[fracs]}];
(* data points to plot log vs log graph *)
model = LinearModelFit[z,u,u];
(* linear regression for data points *)
f = 1 - (model[2] - model[1])
(* fractal dimension*)
];


fractaldata = Table[fractals[data[[1,i]],i],{i,1,Length[data[[1]]]}];
(*fractal dimension calculation for all the grains*)
{"Fractal Divider",fractaldata}
]





Irregularity[res_,exdata_]:=Module[{d,data,normat,inpoints,ellipseqn,ellmatrix,iregata},
d = Dimensions[res[[1]]];
(* dimension of the input image *)
normat = Table[0,{i,1,d[[1]]},{j,1,d[[2]]}];
(* matrix of the size of input image *)
data = exdata[[3]];
(* extracting cmdata *)
inpoints = exdata[[4]];
(* taking inside points of the grains *)
ellipseqn[x_,y_,m_,n_,t_,pc_]:= ((y-pc[[2]])-(Tan[t])(x-pc[[1]]))^2/(m^2 (1+(Tan[t])^2))+ (Tan[t](y-pc[[2]])+(x-pc[[1]]))^2/(n^2 (1+(Tan[t])^2))-1;
(* function of an inclined ellipse *)


ellmatrix[t_,pc_,new_]:= Module[{h,k,snt,cst,xm,ym,m1,mat},
mat = new;
h = data[[t,3]]/2;
k = data[[t,4]]/2;
snt = Sin[data[[t,5]]];
cst = Cos[data[[t,5]]];
xm = Abs[Round[Sqrt[h^2*cst^2+snt^2*k^2]]];
ym = Abs[Round[Sqrt[h^2*snt^2+cst^2*k^2]]];
m1 = Table[If[ellipseqn[a,b,h,k,data[[t,5]],pc]<=0,mat[[a,b]]=1,mat[[a,b]]=0],{a,pc[[1]]-ym,pc[[1]]+ym},{b,pc[[2]]-xm,xm+pc[[2]]}];
{mat,{pc[[1]]-ym,pc[[1]]+ym,pc[[2]]-xm,xm+pc[[2]]}}];
(* function that gives matrix containing best fit ellipse of the grain *)


iregata[t_]:=Module[{grainmat,matconst,finalmat,pcc,ellmat,resmat,r},
pcc = Round[{d[[1]]+1-data[[t,2,2]],data[[t,2,1]]}];

grainmat = SparseArray[Table[inpoints[[t,i]]->(t+1),{i,1,Length[inpoints[[t]]]}],d];
(* generates matrix with individual grain for the complete image dimension *)

ellmat = ellmatrix[t,pcc,normat];
(* generates matrix with best fit ellipse of grain with complete image dimension *)

resmat = grainmat+ellmat[[1]];
(* resultant matrix after addition of both the matrix with complete image dimension *)

matconst = {Min[ellmat[[2,1]],Min[inpoints[[t]][[All,1]]]],Max[ellmat[[2,2]],Max[inpoints[[t]][[All,1]]]],Min[ellmat[[2,3]],Min[inpoints[[t]][[All,2]]]],Max[ellmat[[2,4]],Max[inpoints[[t]][[All,2]]]]};
finalmat = Take[resmat,{matconst[[1]],matconst[[2]]},{matconst[[3]],matconst[[4]]}];
(* taking out matrix just containing best fit ellipse and grain *)

r = N[(Count[finalmat,t+1,2]+Count[finalmat,1,2])/Count[ellmat[[1]],1,2]];
(* finding irregularity by taking common points *)
r
];

{"Irregularity",Table[iregata[i],{i,1,Length[data]}]}
(* calculates irregularity for each grain  *)
];


Angularity[exdata_,num_,k_ ]:= Module[{boundarypoints,slopeI,listang},
boundarypoints = exdata[[1]];
(* transfers required list of boundary points data for all the grains in this step*)
slopeI[bounds_]:=Module[{n,qr,newlist,padlist,vectanglist,convlist,total,anglelist,degreelist,pdegreelist,diffanglelist, res},
n = Round[N[Length[bounds]/num]];
(*num = number of boundary points to be sampled - fed by the user*)
qr = QuotientRemainder[Length[bounds]-1,n];
(* to normalise each grain into num sided polygon*)
newlist = Table[bounds[[i]],{i,1,Length[bounds],n}];
newlist = If[qr[[2]]==0,newlist,Join[newlist,{Last[bounds]}]];
(* additional points while computing angularity *)
padlist=Join[Take[Take[newlist,-2],1],newlist];

vectanglist=Table[{VectorAngle[padlist[[i]]-padlist[[i+1]],padlist[[i+2]]-padlist[[i+1]]],Cross[Join[padlist[[i+1]]-padlist[[i]],{0}],Join[padlist[[i+2]]-padlist[[i+1]],{0}]]},{i,1,Length[padlist]-2}];
(*vector angle between two vectors*)
convlist=If[vectanglist[[#,2,3]]==0,0,
If[vectanglist[[#,2,3]]<0,-1,1
]
]&/@Range[Length[vectanglist]];
(*convlist assigns 0,-1 or 1 for direction of vector product at each vertex*)
total=Total[convlist];
(*overall direction of rotation within particle boundary*)
anglelist=If[convlist[[#]]==0,Pi,
If[total*convlist[[#]]>0,vectanglist[[#,1]],2Pi-vectanglist[[#,1]]]]&/@Range[Length[convlist]];
(*anglelist is recomputed angle list giving all internal angles*)
degreelist=(180/Pi)(N@anglelist);
(*transformation of angles from radian to degrees*)
pdegreelist=Join[{Last[degreelist]},degreelist];
diffanglelist=(pdegreelist[[#]]-pdegreelist[[#+1]])&/@Range[Length[pdegreelist]-1];
res=Mean[Take[Sort[Abs[diffanglelist]],-k]]
(*k = number of highest differences taken for angularity calculation - fed by the user*)

];

listang = Table[slopeI[boundarypoints[[i]]],{i,1,Length[boundarypoints]}];
(* list of angularity values for each grain *)
{"Angularity",listang}
];


Roundness[data_,listinrad_]:= Module[{inradlist,coordList,dist,circumRadius,CurvatureRadius,radlist},
inradlist = listinrad[[All,2]];
coordList = data[[1]];
(* transfers required data for this step*)
circumRadius[a_,b_,c_]:= a*b*c/Sqrt[(a+b+c)*(a+b-c)*(b+c-a)*(c+a-b)];
(* function for calculating radius of curvature at a particular point B for three points A,B,C *)
dist[x_,y_]:=Norm[{Norm[x[[1]]-y[[1]]],Norm[x[[2]]-y[[2]]]}];
(* function to find distance between two points x and y *)


CurvatureRadius[points_,inrad_]:=Module[{t,listrad,adlist,adrad,n1,n2,m,newrad,exrad,exradplot,plot,selrad},
t = Round[Length[points]/30];
(* to normalise grain boundaries *)
listrad = Table[N[If[VectorAngle[points[[i]]-points[[i+t]],points[[i+2t]]-points[[i+t]]]==Pi,0,circumRadius[dist[points[[i]],points[[i+t]]],dist[points[[i]],points[[i+2t]]],dist[points[[i+2t]],points[[i+t]]]]]],{i,1,Length[points]-2t}];
(* radius of curvature at each boundary point *)
adlist = DeleteDuplicates[Join[Take[points,-2t],Take[points,2t]]];
(* additional points for completing the loop *)
adrad = Table[N[If[VectorAngle[adlist[[i]]-adlist[[i+t]],adlist[[i+2t]]-adlist[[i+t]]]==Pi,0,circumRadius[dist[adlist[[i]],adlist[[i+t]]],dist[adlist[[i]],adlist[[i+2t]]],dist[adlist[[i+2t]],adlist[[i+t]]]]]],{i,1,Length[adlist]-2t}];
(* radius of curvature at additional points *)
n1= Take[adrad,-t];
n2 = Take[adrad,t];
newrad = Join[n1,listrad,n2];
(* overall radius of curvature for all the points at the boundary *)
m = Max[newrad];
newrad = newrad/.{0.0->2*m};
(* to eliminate points where the three points lie on a st line *)
exrad = Table[If[newrad[[i]]>inrad,newrad[[i]] = 2*m, newrad[[i]]=newrad[[i]]],{i,1,Length[newrad]}];
exradplot = Table[Join[points[[i]],{exrad[[i]]}],{i,1,Length[points]-1}];
selrad = Mean[Select[newrad,#<inrad&]]/inrad;
(* to eliminate the points where radius of curvature is greater than radius of largest inscribed circle and calculate its mean *)
plot =ListPlot[Style[#[[;;2]],PointSize[.013],ColorData["Temperature"][#[[3]]/Max[exradplot[[All,3]]]]]&/@exradplot,AspectRatio->1];
selrad
(* gives result *)
];
(*function for calculating roundness of individual grain with boundary points and largest inscribed circle as input*)

{"Roundness",Table[CurvatureRadius[coordList[[i]],inradlist[[i]]],{i,1,Length[coordList]}]}
(* gives roundness value for each grain *)
];


CircularityFunction[circumdata_,inrad_]:= {"Circularity",Table[N[Sqrt[inrad[[i,2]]*2/circumdata[[i]]]],{i,1,Length[inrad]}]};
(* takes componentmeasurement data and computes circularity *)


ResultTable[exdata_,parameters_,others_,size_,listinrad_]:= Module[{inradlist,heading,datamatrix,label,cmd,opheading,opdata,ap,rect,comp,sol,con,modr,sizehead,sizemat},
inradlist = listinrad[[All,2]];
(*list of radius for largest inscribed circle*)
label = exdata[[3,All,1]]-ConstantArray[1,Length[exdata[[3]]]];
heading = parameters[[All,1]];
(* takes heading for each computed shape parameter from the list provided *)
datamatrix = parameters[[All,2]];
(* takes result for each computed shape parameter from the list provided *)
cmd = exdata[[3]];
(* takes componentmeasurement data for other parameter computation *)
opheading = {"Aspect Ratio","Rectangularity","Compactness","Solidity","Convexity","ModRatio"};
(* to give heading for other parameters *)
ap = Table[N[cmd[[i,3]]/cmd[[i,4]]],{i,1,Length[cmd]}];
rect = cmd[[All,6]];
comp = Table[N[Sqrt[4*cmd[[i,7]]/Pi]*2/cmd[[i,3]]],{i,1,Length[cmd]}];
sol = Table[N[cmd[[i,7]]/cmd[[i,8]]],{i,1,Length[cmd]}];
con = Table[N[cmd[[i,9]]/cmd[[i,10]]],{i,1,Length[cmd]}];
modr = Table[N[2*inradlist[[i]]/cmd[[i,11]]],{i,1,Length[cmd]}];
(* calculates other parameters *)
opdata = {ap,rect,comp,sol,con,modr};
If[Length[size]==1,
sizehead=size[[1,All,1]];
sizemat=size[[1,All,2]];
If[others,
TableForm[ArrayFlatten[{{"Label",{Join[heading,opheading,sizehead]}},{{label}\[Transpose],Transpose[Join[datamatrix,opdata,sizemat]]}}]],TableForm[ArrayFlatten[{{"Label",{Join[heading,sizehead]}},{{label}\[Transpose],Transpose[Join[datamatrix,sizemat]]}}]]],
If[others,
TableForm[ArrayFlatten[{{"Label",{Join[heading,opheading]}},{{label}\[Transpose],Transpose[Join[datamatrix,opdata]]}}]],TableForm[ArrayFlatten[{{"Label",{heading}},{{label}\[Transpose],Transpose[datamatrix]}}]]
]
]
];


SizeTransform[classwidth_,sizedata_,num_]:=Module[{sizelist,binlist,nbin,dat,fucn,uniformDistribution,len,f,b,resb,mspdist, mspdist1,resdata,mspdist2,resdist,data,dist,k,emptres,result,resp,nresp,vresp,nvresp,nresn,vresn,nvresn},
sizelist=sizedata[[num,2]];
(*gets size list from the data*)
nbin=Ceiling[Max[sizelist]/classwidth];
(*number of bins*)
binlist=Table[(classwidth){(i-1),i},{i,1,nbin}];
(*list of bins*)
dat=Table[100*N[Length[Select[sizelist,binlist[[i,1]]<= #<binlist[[i,2]]&]]]/Length[sizelist],{i,1,Length[binlist]}];

(*proportion of data in each bin given by first two column of output*)
fucn[r_,n_]:=Table[N[(Sqrt[r^2- ((i-1)*(r/n))^2]- Sqrt[r^2- (i*(r/n))^2])/r],{i, 1, n}];
(*fucn gives probability distribution of n classes in a monodisperse distribution of radius r*)

uniformDistribution[n_]:=Module[{factor,funl,list,nlist,res},
funl[r_,rm_]:=Table[N[(Sqrt[r^2- (i-1)^2]- Sqrt[r^2- i^2])/rm],{i,1,r}];
list=Table[funl[n-i+1,n],{i,1,n}];
nlist = Table[Total[Take[list,n-i+1][[All,i]]],{i,1,n}];
factor = 100/Total[nlist];
res = factor*nlist
];

(*uniformDistribution gives probability distribution of n classes in a uniform distribution*)

k= Length[dat];
dist=uniformDistribution[k];
emptres = ConstantArray[0,k];
data = (dist[[k]]/dat[[k]])*dat;
b=100/k;

While[k>0,
len = Length[data];
f = data[[len]]/dist[[len]];
resb = f*b;
mspdist = fucn[1,len];
mspdist2 = (dist[[len]]/mspdist[[len]])*mspdist;
resdist = Take[dist-mspdist2,len-1];
mspdist1 = (data[[len]]/mspdist[[len]])*mspdist;
resdata = Take[If[data[[len]]>0,data-mspdist1,data],len-1];
emptres[[len]]=resb;
data=resdata;
dist=resdist;
k--];
(*stripping and calculating raw H(r)*)
result=emptres;
resp=If[result[[#]]>0,result[[#]],0]&/@Range[Length[result]];
(*filtering antishpere results*)
nresp=resp*100/Total[resp];
(*normalised results for only sphere H(R)*)
vresp=(resp[[#]]*(#)^3)&/@Range[Length[resp]];
(*volume dist for only sphere v(R)*)
nvresp=vresp*100/Total[vresp];
(*normalised volume dist for only sphere v(R)*)
nresn=result*100/Total[Abs[result]];
(*normalised results for sphere and antispheres H(R)*)
vresn=(result[[#]]*(#)^3)&/@Range[Length[result]];
(*volume dist for sphere and antispheres v(R)*)
nvresn=vresn*100/Total[Abs[vresn]];
(*normalised volume dist for sphere and antispheres v(R)*)

TableForm[Transpose[{Join[{"r"},classwidth*Range[nbin]],Join[{"h(r)"},dat],Join[{"sph h(R)"},nresp],Join[{"sph v(R)"},nvresp],Join[{"sph&asph h(R)"},nresn],Join[{"sph&asph v(R)"},nvresn]}]]
(*output*)
];


FourierOutput[descriptors_,data_,filename_]:=Module[{label,listofdesc,reallist,imaglist,list,list2,finallist},
label=data[[3,All,1]]-1;
(* imports the list of labels *)
listofdesc =  Table[Transpose[{Re[descriptors[[i]]],Im[descriptors[[i]]]}],{i,1,Length[descriptors]}];
reallist = Table[listofdesc[[i]][[All,1]],{i,1,Length[listofdesc]}];
imaglist =  Table[listofdesc[[i]][[All,2]],{i,1,Length[listofdesc]}];
(* seperates out real and imaginery part of descriptors *)
list = Range[2Length[reallist]];
Table[list[[2i-1]]= reallist[[i]],{i,1,Length[reallist]}];
Table[list[[2i]]= imaglist[[i]],{i,1,Length[imaglist]}];
(* list contains descriptors aligned for tabular display *)
list2 =  Range[2Length[reallist]];
Table[list2[[2i-1]]= {label[[i]]*"a"},{i,1,Length[reallist]}];
Table[list2[[2i]]= {label[[i]]*"b"},{i,1,Length[imaglist]}];
(* list2 contains labels aligned for tabular display *)
finallist = Join[Transpose[list2],Transpose[list]];
(* final list for tabular display of labels and descriptors *)
Export[filename,finallist]
(* exports data to excel file *)
];


GrainMapping[res_,parameter_,range_,color_]:=Module[{matrix,data,label,exc,blend,grules,excrules,rules},
matrix=res[[2]]/.{1-> 0};
data=parameter[[2]];
blend=Blend[color,(data[[#]]-range[[1]])/(range[[2]]-range[[1]])]&/@Range[Length[data]];
label=res[[1]]+1;
grules=(label[[#]]->blend[[#]])&/@Range[Length[label]];

If[Length[res[[5]]]>0,

exc=res[[5]]+1;
excrules=(exc[[#]]->Black)&/@Range[Length[exc]];
rules=Join[grules,excrules],

rules=grules;
];

Colorize[matrix,ColorRules->rules]
];
